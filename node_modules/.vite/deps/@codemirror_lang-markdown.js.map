{
  "version": 3,
  "sources": ["../../@lezer/markdown/dist/index.js", "../../@lezer/lr/dist/index.js", "../../@lezer/html/dist/index.js", "../../@lezer/css/dist/index.js", "../../@codemirror/lang-css/dist/index.js", "../../@lezer/javascript/dist/index.js", "../../@codemirror/lang-javascript/dist/index.js", "../../@codemirror/lang-html/dist/index.js", "../../@codemirror/lang-markdown/dist/index.js"],
  "sourcesContent": ["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n    Type[Type[\"URL\"] = 44] = \"URL\";\n})(Type || (Type = {}));\n/**\nData structure used to accumulate a block's content during [leaf\nblock parsing](#BlockParser.leaf).\n*/\nclass LeafBlock {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the block.\n    */\n    start, \n    /**\n    The block's text content.\n    */\n    content) {\n        this.start = start;\n        this.content = content;\n        /**\n        @internal\n        */\n        this.marks = [];\n        /**\n        The block parsers active for this block.\n        */\n        this.parsers = [];\n    }\n}\n/**\nData structure used during block-level per-line parsing.\n*/\nclass Line {\n    constructor() {\n        /**\n        The line's full text.\n        */\n        this.text = \"\";\n        /**\n        The base indent provided by the composite contexts (that have\n        been handled so far).\n        */\n        this.baseIndent = 0;\n        /**\n        The string position corresponding to the base indent.\n        */\n        this.basePos = 0;\n        /**\n        The number of contexts handled @internal\n        */\n        this.depth = 0;\n        /**\n        Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        */\n        this.markers = [];\n        /**\n        The position of the next non-whitespace character beyond any\n        list, blockquote, or other composite block markers.\n        */\n        this.pos = 0;\n        /**\n        The column of the next non-whitespace character.\n        */\n        this.indent = 0;\n        /**\n        The character code of the character after `pos`.\n        */\n        this.next = -1;\n    }\n    /**\n    @internal\n    */\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /**\n    @internal\n    */\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /**\n    Skip whitespace after the given position, return the position of\n    the next non-space character or the end of the line if there's\n    only space after `from`.\n    */\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /**\n    @internal\n    */\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /**\n    Move the line's base position forward to the given position.\n    This should only be called by composite [block\n    parsers](#BlockParser.parse) or [markup skipping\n    functions](#NodeSpec.composite).\n    */\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /**\n    Move the line's base position forward to the given _column_.\n    */\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /**\n    Store a composite-block-level marker. Should be called from\n    [markup skipping functions](#NodeSpec.composite) when they\n    consume any non-whitespace characters.\n    */\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /**\n    Find the column position at `to`, optionally starting at a given\n    position and column.\n    */\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /**\n    Find the position corresponding to the given column.\n    */\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /**\n    @internal\n    */\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length &&\n        cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/**\nBlock-level parsing functions get access to this context object.\n*/\nclass BlockContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser configuration used.\n    */\n    parser, \n    /**\n    @internal\n    */\n    input, fragments, \n    /**\n    @internal\n    */\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /**\n        For reused nodes on gaps, we can't directly put the original\n        node into the tree, since that may be bigger than its parent.\n        When this happens, we create a dummy tree that is replaced by\n        the proper node in `injectGaps` @internal\n        */\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /**\n        The range index that absoluteLineStart points into @internal\n        */\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            for (let markI = 0;;) {\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\n                    let mark = line.markers[markI++];\n                    this.addNode(mark.type, mark.from, mark.to);\n                }\n                if (!next)\n                    break;\n                this.finishContext();\n            }\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /**\n    The number of parent blocks surrounding the current block.\n    */\n    get depth() {\n        return this.stack.length;\n    }\n    /**\n    Get the type of the parent block at the given depth. When no\n    depth is passed, return the type of the innermost parent.\n    */\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /**\n    Move to the next input line. This should only be called by\n    (non-composite) [block parsers](#BlockParser.parse) that consume\n    the line directly, or leaf block parser\n    [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    consume the current line (and return true).\n    */\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    /**\n    Retrieve the text of the line after the current one, without\n    actually moving the context's current line forward.\n    */\n    peekLine() {\n        return this.scanLine(this.absoluteLineEnd + 1).text;\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /**\n    @internal\n    Collect the text for the next line.\n    */\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /**\n    @internal\n    Populate this.line with the content of the next line. Skip\n    leading characters covered by composite blocks.\n    */\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /**\n    The end position of the previous line.\n    */\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /**\n    @internal\n    */\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /**\n    Start a composite block. Should only be called from [block\n    parser functions](#BlockParser.parse) that return null.\n    */\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /**\n    @internal\n    */\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /**\n    Add a block element. Can be called by [block\n    parsers](#BlockParser.parse).\n    */\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /**\n    Add a block element from a [leaf parser](#LeafBlockParser). This\n    makes sure any extra composite block markup (such as blockquote\n    markers) inside the block are also added to the syntax tree.\n    */\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /**\n    @internal\n    */\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /**\n    @internal\n    */\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /**\n    @internal\n    */\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/**\nA Markdown parser configuration.\n*/\nclass MarkdownParser extends Parser {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser's syntax [node\n    types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    */\n    nodeSet, \n    /**\n    @internal\n    */\n    blockParsers, \n    /**\n    @internal\n    */\n    leafBlockParsers, \n    /**\n    @internal\n    */\n    blockNames, \n    /**\n    @internal\n    */\n    endLeafBlock, \n    /**\n    @internal\n    */\n    skipContextMarkup, \n    /**\n    @internal\n    */\n    inlineParsers, \n    /**\n    @internal\n    */\n    inlineNames, \n    /**\n    @internal\n    */\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /**\n        @internal\n        */\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Reconfigure the parser.\n    */\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /**\n    @internal\n    */\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /**\n    Parse the given piece of inline text at the given offset,\n    returning an array of [`Element`](#Element) objects representing\n    the inline content.\n    */\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/**\nElements are used to compose syntax nodes during parsing.\n*/\nclass Element {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The node's\n    [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    */\n    type, \n    /**\n    The start of the node, as an offset from the start of the document.\n    */\n    from, \n    /**\n    The end of the node.\n    */\n    to, \n    /**\n    The node's child nodes @internal\n    */\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /**\n    @internal\n    */\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /**\n    @internal\n    */\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{S}|\\\\p{P}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url) {\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\n                elt(Type.LinkMark, start, start + 1),\n                // url[0] includes the closing bracket, so exclude it from this slice\n                elt(Type.URL, start + 1, start + url[0].length),\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\n            ]));\n        }\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0 /* Mark.None */;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            // The destination and title must be separated by whitespace\n            if (pos != dest.to) {\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n                if (title)\n                    pos = cx.skipSpace(title.to);\n            }\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/**\nInline parsing functions get access to this context, and use it to\nread the content and emit syntax nodes.\n*/\nclass InlineContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser that is being used.\n    */\n    parser, \n    /**\n    The text of this inline section.\n    */\n    text, \n    /**\n    The starting offset of the section in the document.\n    */\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /**\n        @internal\n        */\n        this.parts = [];\n    }\n    /**\n    Get the character code at the given (document-relative)\n    position.\n    */\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /**\n    The position of the end of this inline section.\n    */\n    get end() { return this.offset + this.text.length; }\n    /**\n    Get a substring of this inline section. Again uses\n    document-relative positions.\n    */\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /**\n    @internal\n    */\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /**\n    Add a [delimiter](#DelimiterType) at this given position. `open`\n    and `close` indicate whether this delimiter is opening, closing,\n    or both. Returns the end of the delimiter, for convenient\n    returning from [parse functions](#InlineParser.parse).\n    */\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    }\n    /**\n    Returns true when there is an unmatched link or image opening\n    token before the current position.\n    */\n    get hasOpenLink() {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\n                return true;\n        }\n        return false;\n    }\n    /**\n    Add an inline element. Returns the end of the element.\n    */\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /**\n    Resolve markers between this.parts.length and from, wrapping matched markers in the\n    appropriate node and updating the content of this.parts. @internal\n    */\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /**\n    Find an opening delimiter of the given type. Returns `null` if\n    no delimiter is found, or an index that can be passed to\n    [`takeContent`](#InlineContext.takeContent) otherwise.\n    */\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /**\n    Remove all inline elements and delimiters starting from the\n    given index (which you should get from\n    [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    resolve delimiters inside of them, and return them as an array\n    of elements.\n    */\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /**\n    Skip space after the given (document) position, returning either\n    the position of the next non-space character or the end of the\n    section.\n    */\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    \"URL Autolink\": tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/**\nThe default CommonMark parser.\n*/\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/**\nCreate a Markdown extension to enable nested parsing on code\nblocks and/or embedded HTML.\n*/\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag || id == Type.CommentBlock)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/**\nAn extension that implements\n[GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\nStrikethrough syntax using `~~` delimiters.\n*/\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\n// Parse a line as a table row and return the row count. When `elts`\n// is given, push syntax elements for the content onto it.\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/**\nThis extension provides\n[GFM-style](https://github.github.com/gfm/#tables-extension-)\ntables, using syntax like this:\n\n```\n| head 1 | head 2 |\n| ---    | ---    |\n| cell 1 | cell 2 |\n```\n*/\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.peekLine();\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/**\nExtension providing\n[GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\ntask list items, where list items can be prefixed with `[ ]` or\n`[x]` to add a checkbox.\n*/\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/**\nExtension that implements autolinking for\n`www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\naddresses.\n*/\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                if (pos && /\\w/.test(cx.text[pos - 1]))\n                    return -1;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && cx.hasOpenLink) {\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\n                        end = pos + noBracket[0].length;\n                    }\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/**\nExtension bundle containing [`Table`](#Table),\n[`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n[`Autolink`](#Autolink).\n*/\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsuperscript using `^` markers.\n*/\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsubscript using `~` markers.\n*/\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/**\nExtension that parses two colons with only letters, underscores,\nand numbers between them as `Emoji` nodes.\n*/\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n", "import { Parser, NodeProp, NodeSet, NodeType, DefaultBufferLength, Tree, IterMode } from '@lezer/common';\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parse that this stack is part of @internal\n    */\n    p, \n    /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */\n    stack, \n    /**\n    The current parse state @internal\n    */\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */\n    reducePos, \n    /**\n    The input position up to which this stack has parsed.\n    */\n    pos, \n    /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */\n    bufferBase, \n    /**\n    @internal\n    */\n    curContext, \n    /**\n    @internal\n    */\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */\n    reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */;\n        if (lookaheadRecord)\n            this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            }\n            else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */\n    storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */ &&\n            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) {\n                let mustMove = false;\n                for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove)\n                    while (index > 0 && this.buffer[index - 2] > end) {\n                        // Move this record forward\n                        this.buffer[index] = this.buffer[index - 4];\n                        this.buffer[index + 1] = this.buffer[index - 3];\n                        this.buffer[index + 2] = this.buffer[index - 2];\n                        this.buffer[index + 3] = this.buffer[index - 1];\n                        index -= 4;\n                        if (size > 4)\n                            size -= 4;\n                    }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */\n    shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */) {\n            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))\n                    this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode)\n                this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */\n    apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0)\n                return false;\n            if ((action & 65536 /* Action.ReduceFlag */) == 0)\n                return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */\n    forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)\n            return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null)\n                    return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */\n    findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth) => {\n            if (seen.includes(state))\n                return;\n            seen.push(state);\n            return parser.allActions(state, (action) => {\n                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;\n                else if (action & 65536 /* Action.ReduceFlag */) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)\n                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;\n                    }\n                }\n                else {\n                    let found = explore(action, depth + 1);\n                    if (found != null)\n                        return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&\n            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */\n    restart() {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */\n    get parser() { return this.p.parser; }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */) {\n                value = 65535 /* Encode.BigVal */;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */)\n                next--;\n            if (next >= 34 /* Encode.Gap1 */)\n                next--;\n            let digit = next - 32 /* Encode.Start */;\n            if (digit >= 46 /* Encode.Base */) {\n                digit -= 46 /* Encode.Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Encode.Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    input, \n    /**\n    @internal\n    */\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */\n        this.chunk = \"\";\n        /**\n        @internal\n        */\n        this.chunkOff = 0;\n        /**\n        Backup chunk\n        */\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */\n        this.next = -1;\n        /**\n        @internal\n        */\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */\n    clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to)\n            return pos;\n        for (let range of this.ranges)\n            if (range.to > pos)\n                return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsing—when looking forward—or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */\n    acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n    constructor(data, precTable, elseToken) {\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for (;;) {\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1)\n                break;\n            if (this.elseToken == null)\n                return;\n            if (!atEof)\n                skipped++;\n            if (nextPos == null)\n                break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term ||\n                        overrides(term, input.token.value, precTable, precOffset))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for (; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize.Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Term.Err */;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n                if (data[i] == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n            let [s] = stacks;\n            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Rec.Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose)\n                    console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */)\n                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n    /**\n    Define a context tracker.\n    */\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends Parser {\n    /**\n    @internal\n    */\n    constructor(spec) {\n        super();\n        /**\n        @internal\n        */\n        this.wrappers = [];\n        if (spec.version != 14 /* File.Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                if (typeof prop == \"string\")\n                    prop = NodeProp[prop];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        if (spec.propSources)\n            this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for (let i = 0; i < this.specializerSpecs.length; i++)\n            this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* Seq.End */) {\n                    if (data[i + 1] == 1 /* Seq.Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* ParseState.Size */) + slot];\n    }\n    /**\n    @internal\n    */\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n    }\n    /**\n    @internal\n    */\n    validAction(state, action) {\n        return !!this.allActions(state, a => a == action ? true : null);\n    }\n    /**\n    @internal\n    */\n    allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n        let result = deflt ? action(deflt) : undefined;\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* Seq.End */) {\n                if (this.data[i + 1] == 1 /* Seq.Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n                let found = config.specializers.find(r => r.from == s.external);\n                if (!found)\n                    return s;\n                let spec = Object.assign(Object.assign({}, s), { external: found.to });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */\n    hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */\n    get eofTerm() { return this.maxNode + 1; }\n    /**\n    The type of top node produced by the parser.\n    */\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /**\n    @internal\n    */\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n        return (value, stack) => (spec.external(value, stack) << 1) | mask;\n    }\n    return spec.get;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, LocalTokenGroup, Stack };\n", "import { ContextTracker, ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { parseMixed } from '@lezer/common';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst scriptText = 54,\n  StartCloseScriptTag = 1,\n  styleText = 55,\n  StartCloseStyleTag = 2,\n  textareaText = 56,\n  StartCloseTextareaTag = 3,\n  EndTag = 4,\n  SelfClosingEndTag = 5,\n  StartTag = 6,\n  StartScriptTag = 7,\n  StartStyleTag = 8,\n  StartTextareaTag = 9,\n  StartSelfClosingTag = 10,\n  StartCloseTag = 11,\n  NoMatchStartCloseTag = 12,\n  MismatchedStartCloseTag = 13,\n  missingCloseTag = 57,\n  IncompleteCloseTag = 14,\n  commentContent$1 = 58,\n  Element = 20,\n  TagName = 22,\n  Attribute = 23,\n  AttributeName = 24,\n  AttributeValue = 26,\n  UnquotedAttributeValue = 27,\n  ScriptText = 28,\n  StyleText = 31,\n  TextareaText = 34,\n  OpenTag = 36,\n  CloseTag = 37,\n  Dialect_noMatch = 0,\n  Dialect_selfClosing = 1;\n\n/* Hand-written tokenizers for HTML. */\n\nconst selfClosers = {\n  area: true, base: true, br: true, col: true, command: true,\n  embed: true, frame: true, hr: true, img: true, input: true,\n  keygen: true, link: true, meta: true, param: true, source: true,\n  track: true, wbr: true, menuitem: true\n};\n\nconst implicitlyClosed = {\n  dd: true, li: true, optgroup: true, option: true, p: true,\n  rp: true, rt: true, tbody: true, td: true, tfoot: true,\n  th: true, tr: true\n};\n\nconst closeOnOpen = {\n  dd: {dd: true, dt: true},\n  dt: {dd: true, dt: true},\n  li: {li: true},\n  option: {option: true, optgroup: true},\n  optgroup: {optgroup: true},\n  p: {\n    address: true, article: true, aside: true, blockquote: true, dir: true,\n    div: true, dl: true, fieldset: true, footer: true, form: true,\n    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,\n    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,\n    p: true, pre: true, section: true, table: true, ul: true\n  },\n  rp: {rp: true, rt: true},\n  rt: {rp: true, rt: true},\n  tbody: {tbody: true, tfoot: true},\n  td: {td: true, th: true},\n  tfoot: {tbody: true},\n  th: {td: true, th: true},\n  thead: {tbody: true, tfoot: true},\n  tr: {tr: true}\n};\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161\n}\n\nfunction isSpace(ch) {\n  return ch == 9 || ch == 10 || ch == 13 || ch == 32\n}\n\nlet cachedName = null, cachedInput = null, cachedPos = 0;\nfunction tagNameAfter(input, offset) {\n  let pos = input.pos + offset;\n  if (cachedPos == pos && cachedInput == input) return cachedName\n  let next = input.peek(offset);\n  while (isSpace(next)) next = input.peek(++offset);\n  let name = \"\";\n  for (;;) {\n    if (!nameChar(next)) break\n    name += String.fromCharCode(next);\n    next = input.peek(++offset);\n  }\n  // Undefined to signal there's a <? or <!, null for just missing\n  cachedInput = input; cachedPos = pos;\n  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null\n}\n\nconst lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dash = 45;\n\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n}\n\nconst startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];\n\nconst elementContext = new ContextTracker({\n  start: null,\n  shift(context, term, stack, input) {\n    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  reduce(context, term) {\n    return term == Element && context ? context.parent : context\n  },\n  reuse(context, node, stack, input) {\n    let type = node.type.id;\n    return type == StartTag || type == OpenTag\n      ? new ElementContext(tagNameAfter(input, 1) || \"\", context) : context\n  },\n  strict: false\n});\n\nconst tagStart = new ExternalTokenizer((input, stack) => {\n  if (input.next != lessThan) {\n    // End of file, close any open tags\n    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);\n    return\n  }\n  input.advance();\n  let close = input.next == slash;\n  if (close) input.advance();\n  let name = tagNameAfter(input, 0);\n  if (name === undefined) return\n  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)\n\n  let parent = stack.context ? stack.context.name : null;\n  if (close) {\n    if (name == parent) return input.acceptToken(StartCloseTag)\n    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)\n    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)\n    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return\n    input.acceptToken(MismatchedStartCloseTag);\n  } else {\n    if (name == \"script\") return input.acceptToken(StartScriptTag)\n    if (name == \"style\") return input.acceptToken(StartStyleTag)\n    if (name == \"textarea\") return input.acceptToken(StartTextareaTag)\n    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)\n    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);\n    else input.acceptToken(StartTag);\n  }\n}, {contextual: true});\n\nconst commentContent = new ExternalTokenizer(input => {\n  for (let dashes = 0, i = 0;; i++) {\n    if (input.next < 0) {\n      if (i) input.acceptToken(commentContent$1);\n      break\n    }\n    if (input.next == dash) {\n      dashes++;\n    } else if (input.next == greaterThan && dashes >= 2) {\n      if (i >= 3) input.acceptToken(commentContent$1, -2);\n      break\n    } else {\n      dashes = 0;\n    }\n    input.advance();\n  }\n});\n\nfunction inForeignElement(context) {\n  for (; context; context = context.parent)\n    if (context.name == \"svg\" || context.name == \"math\") return true\n  return false\n}\n\nconst endTag = new ExternalTokenizer((input, stack) => {\n  if (input.next == slash && input.peek(1) == greaterThan) {\n    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);\n    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);\n  } else if (input.next == greaterThan) {\n    input.acceptToken(EndTag, 1);\n  }\n});\n\nfunction contentTokenizer(tag, textToken, endToken) {\n  let lastState = 2 + tag.length;\n  return new ExternalTokenizer(input => {\n    // state means:\n    // - 0 nothing matched\n    // - 1 '<' matched\n    // - 2 '</' + possibly whitespace matched\n    // - 3-(1+tag.length) part of the tag matched\n    // - lastState whole tag + possibly whitespace matched\n    for (let state = 0, matchedLen = 0, i = 0;; i++) {\n      if (input.next < 0) {\n        if (i) input.acceptToken(textToken);\n        break\n      }\n      if (state == 0 && input.next == lessThan ||\n          state == 1 && input.next == slash ||\n          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {\n        state++;\n        matchedLen++;\n      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {\n        matchedLen++;\n      } else if (state == lastState && input.next == greaterThan) {\n        if (i > matchedLen)\n          input.acceptToken(textToken, -matchedLen);\n        else\n          input.acceptToken(endToken, -(matchedLen - 2));\n        break\n      } else if ((input.next == 10 /* '\\n' */ || input.next == 13 /* '\\r' */) && i) {\n        input.acceptToken(textToken, 1);\n        break\n      } else {\n        state = matchedLen = 0;\n      }\n      input.advance();\n    }\n  })\n}\n\nconst scriptTokens = contentTokenizer(\"script\", scriptText, StartCloseScriptTag);\n\nconst styleTokens = contentTokenizer(\"style\", styleText, StartCloseStyleTag);\n\nconst textareaTokens = contentTokenizer(\"textarea\", textareaText, StartCloseTextareaTag);\n\nconst htmlHighlighting = styleTags({\n  \"Text RawText\": tags.content,\n  \"StartTag StartCloseTag SelfClosingEndTag EndTag\": tags.angleBracket,\n  TagName: tags.tagName,\n  \"MismatchedCloseTag/TagName\": [tags.tagName,  tags.invalid],\n  AttributeName: tags.attributeName,\n  \"AttributeValue UnquotedAttributeValue\": tags.attributeValue,\n  Is: tags.definitionOperator,\n  \"EntityReference CharacterReference\": tags.character,\n  Comment: tags.blockComment,\n  ProcessingInst: tags.processingInstruction,\n  DoctypeDecl: tags.documentMeta\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z\",\n  stateData: \",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~\",\n  goto: \"%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp\",\n  nodeNames: \"⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl\",\n  maxTerm: 67,\n  context: elementContext,\n  nodeProps: [\n    [\"closedBy\", -10,1,2,3,7,8,9,10,11,12,13,\"EndTag\",6,\"EndTag SelfClosingEndTag\",-4,21,30,33,36,\"CloseTag\"],\n    [\"openedBy\", 4,\"StartTag StartCloseTag\",5,\"StartTag\",-4,29,32,35,37,\"OpenTag\"],\n    [\"group\", -9,14,17,18,19,20,39,40,41,42,\"Entity\",16,\"Entity TextContent\",-3,28,31,34,\"TextContent Entity\"],\n    [\"isolate\", -11,21,29,30,32,33,35,36,37,38,41,42,\"ltr\",-3,26,27,39,\"\"]\n  ],\n  propSources: [htmlHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X\",\n  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],\n  topRules: {\"Document\":[0,15]},\n  dialects: {noMatch: 0, selfClosing: 509},\n  tokenPrec: 511\n});\n\nfunction getAttrs(openTag, input) {\n  let attrs = Object.create(null);\n  for (let att of openTag.getChildren(Attribute)) {\n    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);\n    if (name) attrs[input.read(name.from, name.to)] =\n      !value ? \"\" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);\n  }\n  return attrs\n}\n\nfunction findTagName(openTag, input) {\n  let tagNameNode = openTag.getChild(TagName);\n  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : \" \"\n}\n\nfunction maybeNest(node, input, tags) {\n  let attrs;\n  for (let tag of tags) {\n    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node.node.parent.firstChild, input))))\n      return {parser: tag.parser}\n  }\n  return null\n}\n\n// tags?: {\n//   tag: string,\n//   attrs?: ({[attr: string]: string}) => boolean,\n//   parser: Parser\n// }[]\n// attributes?: {\n//   name: string,\n//   tagName?: string,\n//   parser: Parser\n// }[]\n \nfunction configureNesting(tags = [], attributes = []) {\n  let script = [], style = [], textarea = [], other = [];\n  for (let tag of tags) {\n    let array = tag.tag == \"script\" ? script : tag.tag == \"style\" ? style : tag.tag == \"textarea\" ? textarea : other;\n    array.push(tag);\n  }\n  let attrs = attributes.length ? Object.create(null) : null;\n  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);\n\n  return parseMixed((node, input) => {\n    let id = node.type.id;\n    if (id == ScriptText) return maybeNest(node, input, script)\n    if (id == StyleText) return maybeNest(node, input, style)\n    if (id == TextareaText) return maybeNest(node, input, textarea)\n\n    if (id == Element && other.length) {\n      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs;\n      if (tagName) for (let tag of other) {\n        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(open, input))))) {\n          let close = n.lastChild;\n          let to = close.type.id == CloseTag ? close.from : n.to;\n          if (to > open.to)\n            return {parser: tag.parser, overlay: [{from: open.to, to}]}\n        }\n      }\n    }\n\n    if (attrs && id == Attribute) {\n      let n = node.node, nameNode;\n      if (nameNode = n.firstChild) {\n        let matches = attrs[input.read(nameNode.from, nameNode.to)];\n        if (matches) for (let attr of matches) {\n          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue\n          let value = n.lastChild;\n          if (value.type.id == AttributeValue) {\n            let from = value.from + 1;\n            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);\n            if (to > from) return {parser: attr.parser, overlay: [{from, to}]}\n          } else if (value.type.id == UnquotedAttributeValue) {\n            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}\n          }\n        }\n      }\n    }\n    return null\n  })\n}\n\nexport { configureNesting, parser };\n", "import { ExternalTokenizer, LRParser, LocalTokenGroup } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst descendantOp = 122,\n  Unit = 1,\n  identifier = 123,\n  callee = 124,\n  VariableName = 2,\n  queryIdentifier = 125,\n  queryVariableName = 3,\n  QueryCallee = 4;\n\n/* Hand-written tokenizers for CSS tokens that can't be\n   expressed by Lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,\n               8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];\nconst colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46,\n      hash = 35, percent = 37, ampersand = 38, backslash = 92, newline = 10, asterisk = 42;\n\nfunction isAlpha(ch) { return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 }\n\nfunction isDigit(ch) { return ch >= 48 && ch <= 57 }\n\nfunction isHex(ch) { return isDigit(ch) || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70 }\n\nconst identifierTokens = (id, varName, callee) => (input, stack) => {\n  for (let inside = false, dashes = 0, i = 0;; i++) {\n    let {next} = input;\n    if (isAlpha(next) || next == dash || next == underscore || (inside && isDigit(next))) {\n      if (!inside && (next != dash || i > 0)) inside = true;\n      if (dashes === i && next == dash) dashes++;\n      input.advance();\n    } else if (next == backslash && input.peek(1) != newline) {\n      input.advance();\n      if (isHex(input.next)) {\n        do { input.advance(); } while (isHex(input.next))\n        if (input.next == 32) input.advance();\n      } else if (input.next > -1) {\n        input.advance();\n      }\n      inside = true;\n    } else {\n      if (inside) input.acceptToken(\n        dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee : id\n      );\n      break\n    }\n  }\n};\n\nconst identifiers = new ExternalTokenizer(\n  identifierTokens(identifier, VariableName, callee)\n);\nconst queryIdentifiers = new ExternalTokenizer(\n  identifierTokens(queryIdentifier, queryVariableName, QueryCallee)\n);\n\nconst descendant = new ExternalTokenizer(input => {\n  if (space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (isAlpha(next) || next == underscore || next == hash || next == period ||\n        next == asterisk || next == bracketL || next == colon && isAlpha(input.peek(1)) ||\n        next == dash || next == ampersand)\n      input.acceptToken(descendantOp);\n  }\n});\n\nconst unitToken = new ExternalTokenizer(input => {\n  if (!space.includes(input.peek(-1))) {\n    let {next} = input;\n    if (next == percent) { input.advance(); input.acceptToken(Unit); }\n    if (isAlpha(next)) {\n      do { input.advance(); } while (isAlpha(input.next) || isDigit(input.next))\n      input.acceptToken(Unit);\n    }\n  }\n});\n\nconst cssHighlighting = styleTags({\n  \"AtKeyword import charset namespace keyframes media supports\": tags.definitionKeyword,\n  \"from to selector\": tags.keyword,\n  NamespaceName: tags.namespace,\n  KeyframeName: tags.labelName,\n  KeyframeRangeName: tags.operatorKeyword,\n  TagName: tags.tagName,\n  ClassName: tags.className,\n  PseudoClassName: tags.constant(tags.className),\n  IdName: tags.labelName,\n  \"FeatureName PropertyName\": tags.propertyName,\n  AttributeName: tags.attributeName,\n  NumberLiteral: tags.number,\n  KeywordQuery: tags.keyword,\n  UnaryQueryOp: tags.operatorKeyword,\n  \"CallTag ValueName\": tags.atom,\n  VariableName: tags.variableName,\n  Callee: tags.operatorKeyword,\n  Unit: tags.unit,\n  \"UniversalSelector NestingSelector\": tags.definitionOperator,\n  \"MatchOp CompareOp\": tags.compareOperator,\n  \"ChildOp SiblingOp, LogicOp\": tags.logicOperator,\n  BinOp: tags.arithmeticOperator,\n  Important: tags.modifier,\n  Comment: tags.blockComment,\n  ColorLiteral: tags.color,\n  \"ParenthesizedContent StringLiteral\": tags.string,\n  \":\": tags.punctuation,\n  \"PseudoOp #\": tags.derefOperator,\n  \"; ,\": tags.separator,\n  \"( )\": tags.paren,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_callee = {__proto__:null,lang:38, \"nth-child\":38, \"nth-last-child\":38, \"nth-of-type\":38, \"nth-last-of-type\":38, dir:38, \"host-context\":38, if:84, url:124, \"url-prefix\":124, domain:124, regexp:124};\nconst spec_queryIdentifier = {__proto__:null,or:98, and:98, not:106, only:106, layer:170};\nconst spec_QueryCallee = {__proto__:null,selector:112, layer:166};\nconst spec_AtKeyword = {__proto__:null,\"@import\":162, \"@media\":174, \"@charset\":178, \"@namespace\":182, \"@keyframes\":188, \"@supports\":200, \"@scope\":204};\nconst spec_identifier = {__proto__:null,to:207};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a\",\n  stateData: \"Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~\",\n  goto: \"2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P\",\n  nodeNames: \"⚠ Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles\",\n  maxTerm: 143,\n  nodeProps: [\n    [\"isolate\", -2,5,36,\"\"],\n    [\"openedBy\", 20,\"(\",28,\"[\",31,\"{\"],\n    [\"closedBy\", 21,\")\",29,\"]\",32,\"}\"]\n  ],\n  propSources: [cssHighlighting],\n  skippedNodes: [0,5,106],\n  repeatNodeCount: 15,\n  tokenData: \"JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q\",\n  tokenizers: [descendant, unitToken, identifiers, queryIdentifiers, 1, 2, 3, 4, new LocalTokenGroup(\"m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~\", 28, 129)],\n  topRules: {\"StyleSheet\":[0,6],\"Styles\":[1,105]},\n  specialized: [{term: 124, get: (value) => spec_callee[value] || -1},{term: 125, get: (value) => spec_queryIdentifier[value] || -1},{term: 4, get: (value) => spec_QueryCallee[value] || -1},{term: 25, get: (value) => spec_AtKeyword[value] || -1},{term: 123, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 1963\n});\n\nexport { parser };\n", "import { parser } from '@lezer/css';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\nlet _properties = null;\nfunction properties() {\n    if (!_properties && typeof document == \"object\" && document.body) {\n        let { style } = document.body, names = [], seen = new Set;\n        for (let prop in style)\n            if (prop != \"cssText\" && prop != \"cssFloat\") {\n                if (typeof style[prop] == \"string\") {\n                    if (/[A-Z]/.test(prop))\n                        prop = prop.replace(/[A-Z]/g, ch => \"-\" + ch.toLowerCase());\n                    if (!seen.has(prop)) {\n                        names.push(prop);\n                        seen.add(prop);\n                    }\n                }\n            }\n        _properties = names.sort().map(name => ({ type: \"property\", label: name, apply: name + \": \" }));\n    }\n    return _properties || [];\n}\nconst pseudoClasses = /*@__PURE__*/[\n    \"active\", \"after\", \"any-link\", \"autofill\", \"backdrop\", \"before\",\n    \"checked\", \"cue\", \"default\", \"defined\", \"disabled\", \"empty\",\n    \"enabled\", \"file-selector-button\", \"first\", \"first-child\",\n    \"first-letter\", \"first-line\", \"first-of-type\", \"focus\",\n    \"focus-visible\", \"focus-within\", \"fullscreen\", \"has\", \"host\",\n    \"host-context\", \"hover\", \"in-range\", \"indeterminate\", \"invalid\",\n    \"is\", \"lang\", \"last-child\", \"last-of-type\", \"left\", \"link\", \"marker\",\n    \"modal\", \"not\", \"nth-child\", \"nth-last-child\", \"nth-last-of-type\",\n    \"nth-of-type\", \"only-child\", \"only-of-type\", \"optional\", \"out-of-range\",\n    \"part\", \"placeholder\", \"placeholder-shown\", \"read-only\", \"read-write\",\n    \"required\", \"right\", \"root\", \"scope\", \"selection\", \"slotted\", \"target\",\n    \"target-text\", \"valid\", \"visited\", \"where\"\n].map(name => ({ type: \"class\", label: name }));\nconst values = /*@__PURE__*/[\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"after-white-space\",\n    \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\", \"always\",\n    \"antialiased\", \"appworkspace\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\",\n    \"avoid-page\", \"avoid-region\", \"axis-pan\", \"background\", \"backwards\", \"baseline\", \"below\",\n    \"bidi-override\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"capitalize\",\n    \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\", \"cell\", \"center\", \"checkbox\", \"circle\",\n    \"cjk-decimal\", \"clear\", \"clip\", \"close-quote\", \"col-resize\", \"collapse\", \"color\", \"color-burn\",\n    \"color-dodge\", \"column\", \"column-reverse\", \"compact\", \"condensed\", \"contain\", \"content\",\n    \"contents\", \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\",\n    \"crop\", \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\", \"destination-in\",\n    \"destination-out\", \"destination-over\", \"difference\", \"disc\", \"discard\", \"disclosure-closed\",\n    \"disclosure-open\", \"document\", \"dot-dash\", \"dot-dot-dash\", \"dotted\", \"double\", \"down\", \"e-resize\",\n    \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\", \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\",\n    \"ethiopic-abegede-gez\", \"ethiopic-halehame-aa-er\", \"ethiopic-halehame-gez\", \"ew-resize\", \"exclusion\",\n    \"expanded\", \"extends\", \"extra-condensed\", \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fill-box\",\n    \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\", \"forwards\", \"from\",\n    \"geometricPrecision\", \"graytext\", \"grid\", \"groove\", \"hand\", \"hard-light\", \"help\", \"hidden\", \"hide\",\n    \"higher\", \"highlight\", \"highlighttext\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\", \"infobackground\", \"infotext\",\n    \"inherit\", \"initial\", \"inline\", \"inline-axis\", \"inline-block\", \"inline-flex\", \"inline-grid\",\n    \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\", \"italic\", \"justify\", \"keep-all\",\n    \"landscape\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\", \"line-through\", \"linear\",\n    \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\", \"local\", \"logical\", \"loud\", \"lower\",\n    \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\", \"lowercase\", \"ltr\", \"luminosity\", \"manipulation\",\n    \"match\", \"matrix\", \"matrix3d\", \"medium\", \"menu\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"monospace\", \"move\", \"multiple\", \"multiple_mask_images\", \"multiply\", \"n-resize\", \"narrower\",\n    \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\", \"no-open-quote\", \"no-repeat\", \"none\",\n    \"normal\", \"not-allowed\", \"nowrap\", \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\",\n    \"oblique\", \"opacity\", \"open-quote\", \"optimizeLegibility\", \"optimizeSpeed\", \"outset\", \"outside\",\n    \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\", \"painted\", \"page\", \"paused\",\n    \"perspective\", \"pinch-zoom\", \"plus-darker\", \"plus-lighter\", \"pointer\", \"polygon\", \"portrait\",\n    \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\", \"progress\", \"push-button\", \"radial-gradient\", \"radio\",\n    \"read-only\", \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\", \"relative\", \"repeat\",\n    \"repeating-linear-gradient\", \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\", \"rotateZ\", \"round\",\n    \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\", \"s-resize\", \"sans-serif\", \"saturation\",\n    \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\", \"scroll\", \"scrollbar\", \"scroll-position\",\n    \"se-resize\", \"self-start\", \"self-end\", \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\",\n    \"single\", \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\", \"small\", \"small-caps\",\n    \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"source-atop\", \"source-in\", \"source-out\",\n    \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\", \"start\",\n    \"static\", \"status-bar\", \"stretch\", \"stroke\", \"stroke-box\", \"sub\", \"subpixel-antialiased\", \"svg_masks\",\n    \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\", \"table-caption\", \"table-cell\",\n    \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row\",\n    \"table-row-group\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thick\", \"thin\",\n    \"threeddarkshadow\", \"threedface\", \"threedhighlight\", \"threedlightshadow\", \"threedshadow\", \"to\", \"top\",\n    \"transform\", \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\", \"transparent\",\n    \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unidirectional-pan\", \"unset\", \"up\", \"upper-latin\",\n    \"uppercase\", \"url\", \"var\", \"vertical\", \"vertical-text\", \"view-box\", \"visible\", \"visibleFill\",\n    \"visiblePainted\", \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\", \"window\", \"windowframe\",\n    \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\", \"xx-large\", \"xx-small\"\n].map(name => ({ type: \"keyword\", label: name })).concat(/*@__PURE__*/[\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n].map(name => ({ type: \"constant\", label: name })));\nconst tags = /*@__PURE__*/[\n    \"a\", \"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\", \"blockquote\", \"body\",\n    \"br\", \"button\", \"canvas\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"dd\", \"del\",\n    \"details\", \"dfn\", \"dialog\", \"div\", \"dl\", \"dt\", \"em\", \"figcaption\", \"figure\", \"footer\",\n    \"form\", \"header\", \"hgroup\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"html\", \"i\", \"iframe\",\n    \"img\", \"input\", \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"meter\", \"nav\", \"ol\", \"output\",\n    \"p\", \"pre\", \"ruby\", \"section\", \"select\", \"small\", \"source\", \"span\", \"strong\", \"sub\", \"summary\",\n    \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"tr\", \"u\", \"ul\"\n].map(name => ({ type: \"type\", label: name }));\nconst atRules = /*@__PURE__*/[\n    \"@charset\", \"@color-profile\", \"@container\", \"@counter-style\", \"@font-face\", \"@font-feature-values\",\n    \"@font-palette-values\", \"@import\", \"@keyframes\", \"@layer\", \"@media\", \"@namespace\", \"@page\",\n    \"@position-try\", \"@property\", \"@scope\", \"@starting-style\", \"@supports\", \"@view-transition\"\n].map(label => ({ type: \"keyword\", label }));\nconst identifier = /^(\\w[\\w-]*|-\\w[\\w-]*|)$/, variable = /^-(-[\\w-]*)?$/;\nfunction isVarArg(node, doc) {\n    var _a;\n    if (node.name == \"(\" || node.type.isError)\n        node = node.parent || node;\n    if (node.name != \"ArgList\")\n        return false;\n    let callee = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstChild;\n    if ((callee === null || callee === void 0 ? void 0 : callee.name) != \"Callee\")\n        return false;\n    return doc.sliceString(callee.from, callee.to) == \"var\";\n}\nconst VariablesByNode = /*@__PURE__*/new NodeWeakMap();\nconst declSelector = [\"Declaration\"];\nfunction astTop(node) {\n    for (let cur = node;;) {\n        if (cur.type.isTop)\n            return cur;\n        if (!(cur = cur.parent))\n            return node;\n    }\n}\nfunction variableNames(doc, node, isVariable) {\n    if (node.to - node.from > 4096) {\n        let known = VariablesByNode.get(node);\n        if (known)\n            return known;\n        let result = [], seen = new Set, cursor = node.cursor(IterMode.IncludeAnonymous);\n        if (cursor.firstChild())\n            do {\n                for (let option of variableNames(doc, cursor.node, isVariable))\n                    if (!seen.has(option.label)) {\n                        seen.add(option.label);\n                        result.push(option);\n                    }\n            } while (cursor.nextSibling());\n        VariablesByNode.set(node, result);\n        return result;\n    }\n    else {\n        let result = [], seen = new Set;\n        node.cursor().iterate(node => {\n            var _a;\n            if (isVariable(node) && node.matchContext(declSelector) && ((_a = node.node.nextSibling) === null || _a === void 0 ? void 0 : _a.name) == \":\") {\n                let name = doc.sliceString(node.from, node.to);\n                if (!seen.has(name)) {\n                    seen.add(name);\n                    result.push({ label: name, type: \"variable\" });\n                }\n            }\n        });\n        return result;\n    }\n}\n/**\nCreate a completion source for a CSS dialect, providing a\npredicate for determining what kind of syntax node can act as a\ncompletable variable. This is used by language modes like Sass and\nLess to reuse this package's completion logic.\n*/\nconst defineCSSCompletionSource = (isVariable) => context => {\n    let { state, pos } = context, node = syntaxTree(state).resolveInner(pos, -1);\n    let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == \"-\";\n    if (node.name == \"PropertyName\" ||\n        (isDash || node.name == \"TagName\") && /^(Block|Styles)$/.test(node.resolve(node.to).name))\n        return { from: node.from, options: properties(), validFor: identifier };\n    if (node.name == \"ValueName\")\n        return { from: node.from, options: values, validFor: identifier };\n    if (node.name == \"PseudoClassName\")\n        return { from: node.from, options: pseudoClasses, validFor: identifier };\n    if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc))\n        return { from: isVariable(node) || isDash ? node.from : pos,\n            options: variableNames(state.doc, astTop(node), isVariable),\n            validFor: variable };\n    if (node.name == \"TagName\") {\n        for (let { parent } = node; parent; parent = parent.parent)\n            if (parent.name == \"Block\")\n                return { from: node.from, options: properties(), validFor: identifier };\n        return { from: node.from, options: tags, validFor: identifier };\n    }\n    if (node.name == \"AtKeyword\")\n        return { from: node.from, options: atRules, validFor: identifier };\n    if (!context.explicit)\n        return null;\n    let above = node.resolve(pos), before = above.childBefore(pos);\n    if (before && before.name == \":\" && above.name == \"PseudoClassSelector\")\n        return { from: pos, options: pseudoClasses, validFor: identifier };\n    if (before && before.name == \":\" && above.name == \"Declaration\" || above.name == \"ArgList\")\n        return { from: pos, options: values, validFor: identifier };\n    if (above.name == \"Block\" || above.name == \"Styles\")\n        return { from: pos, options: properties(), validFor: identifier };\n    return null;\n};\n/**\nCSS property, variable, and value keyword completion source.\n*/\nconst cssCompletionSource = /*@__PURE__*/defineCSSCompletionSource(n => n.name == \"VariableName\");\n\n/**\nA language provider based on the [Lezer CSS\nparser](https://github.com/lezer-parser/css), extended with\nhighlighting and indentation information.\n*/\nconst cssLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"css\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Declaration: /*@__PURE__*/continuedIndent()\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block KeyframeList\": foldInside\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*\\}$/,\n        wordChars: \"-\"\n    }\n});\n/**\nLanguage support for CSS.\n*/\nfunction css() {\n    return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));\n}\n\nexport { css, cssCompletionSource, cssLanguage, defineCSSCompletionSource };\n", "import { ContextTracker, ExternalTokenizer, LRParser, LocalTokenGroup } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 315,\n  noSemiType = 316,\n  incdec = 1,\n  incdecPrefix = 2,\n  questionDot = 3,\n  JSXStartTag = 4,\n  insertSemi = 317,\n  spaces = 319,\n  newline = 320,\n  LineComment = 5,\n  BlockComment = 6,\n  Dialect_jsx = 0;\n\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */\n\nconst space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,\n               8201, 8202, 8232, 8233, 8239, 8287, 12288];\n\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44,\n      question = 63, dot = 46, bracketL = 91;\n\nconst trackNewline = new ContextTracker({\n  start: false,\n  shift(context, term) {\n    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline\n  },\n  strict: false\n});\n\nconst insertSemicolon = new ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == braceR || next == -1 || stack.context)\n    input.acceptToken(insertSemi);\n}, {contextual: true, fallback: true});\n\nconst noSemicolon = new ExternalTokenizer((input, stack) => {\n  let {next} = input, after;\n  if (space.indexOf(next) > -1) return\n  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return\n  if (next != braceR && next != semicolon && next != -1 && !stack.context)\n    input.acceptToken(noSemi);\n}, {contextual: true});\n\nconst noSemicolonType = new ExternalTokenizer((input, stack) => {\n  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);\n}, {contextual: true});\n\nconst operatorToken = new ExternalTokenizer((input, stack) => {\n  let {next} = input;\n  if (next == plus || next == minus) {\n    input.advance();\n    if (next == input.next) {\n      input.advance();\n      let mayPostfix = !stack.context && stack.canShift(incdec);\n      input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n    }\n  } else if (next == question && input.peek(1) == dot) {\n    input.advance(); input.advance();\n    if (input.next < 48 || input.next > 57) // No digit after\n      input.acceptToken(questionDot);\n  }\n}, {contextual: true});\n\nfunction identifierChar(ch, start) {\n  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||\n    !start && ch >= 48 && ch <= 57\n}\n\nconst jsx = new ExternalTokenizer((input, stack) => {\n  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return\n  input.advance();\n  if (input.next == slash) return\n  // Scan for an identifier followed by a comma or 'extends', don't\n  // treat this as a start tag if present.\n  let back = 0;\n  while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n  if (identifierChar(input.next, true)) {\n    input.advance();\n    back++;\n    while (identifierChar(input.next, false)) { input.advance(); back++; }\n    while (space.indexOf(input.next) > -1) { input.advance(); back++; }\n    if (input.next == comma) return\n    for (let i = 0;; i++) {\n      if (i == 7) {\n        if (!identifierChar(input.next, true)) return\n        break\n      }\n      if (input.next != \"extends\".charCodeAt(i)) break\n      input.advance();\n      back++;\n    }\n  }\n  input.acceptToken(JSXStartTag, -back);\n});\n\nconst jsHighlight = styleTags({\n  \"get set async static\": tags.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case\": tags.controlKeyword,\n  \"in of await yield void typeof delete instanceof as satisfies\": tags.operatorKeyword,\n  \"let var const using function class extends\": tags.definitionKeyword,\n  \"import export from\": tags.moduleKeyword,\n  \"with debugger new\": tags.keyword,\n  TemplateString: tags.special(tags.string),\n  super: tags.atom,\n  BooleanLiteral: tags.bool,\n  this: tags.self,\n  null: tags.null,\n  Star: tags.modifier,\n  VariableName: tags.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": tags.function(tags.variableName),\n  VariableDefinition: tags.definition(tags.variableName),\n  Label: tags.labelName,\n  PropertyName: tags.propertyName,\n  PrivatePropertyName: tags.special(tags.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": tags.function(tags.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": tags.function(tags.definition(tags.variableName)),\n  \"ClassDeclaration/VariableDefinition\": tags.definition(tags.className),\n  \"NewExpression/VariableName\": tags.className,\n  PropertyDefinition: tags.definition(tags.propertyName),\n  PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),\n  UpdateOp: tags.updateOperator,\n  \"LineComment Hashbang\": tags.lineComment,\n  BlockComment: tags.blockComment,\n  Number: tags.number,\n  String: tags.string,\n  Escape: tags.escape,\n  ArithOp: tags.arithmeticOperator,\n  LogicOp: tags.logicOperator,\n  BitOp: tags.bitwiseOperator,\n  CompareOp: tags.compareOperator,\n  RegExp: tags.regexp,\n  Equals: tags.definitionOperator,\n  Arrow: tags.function(tags.punctuation),\n  \": Spread\": tags.punctuation,\n  \"( )\": tags.paren,\n  \"[ ]\": tags.squareBracket,\n  \"{ }\": tags.brace,\n  \"InterpolationStart InterpolationEnd\": tags.special(tags.brace),\n  \".\": tags.derefOperator,\n  \", ;\": tags.separator,\n  \"@\": tags.meta,\n\n  TypeName: tags.typeName,\n  TypeDefinition: tags.definition(tags.typeName),\n  \"type enum interface implements namespace module declare\": tags.definitionKeyword,\n  \"abstract global Privacy readonly override\": tags.modifier,\n  \"is keyof unique infer asserts\": tags.operatorKeyword,\n\n  JSXAttributeValue: tags.attributeValue,\n  JSXText: tags.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": tags.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": tags.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": tags.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": tags.standard(tags.tagName)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {__proto__:null,export:20, as:25, from:33, default:36, async:41, function:42, in:52, out:55, const:56, extends:60, this:64, true:72, false:72, null:84, void:88, typeof:92, super:108, new:142, delete:154, yield:163, await:167, class:172, public:235, private:235, protected:235, readonly:237, instanceof:256, satisfies:259, import:292, keyof:349, unique:353, infer:359, asserts:395, is:397, abstract:417, implements:419, type:421, let:424, var:426, using:429, interface:435, enum:439, namespace:445, module:447, declare:451, global:455, for:474, of:483, while:486, with:490, do:494, if:498, else:500, switch:504, case:510, try:516, catch:520, finally:524, return:528, throw:532, break:536, continue:540, debugger:544};\nconst spec_word = {__proto__:null,async:129, get:131, set:133, declare:195, public:197, private:197, protected:197, static:199, abstract:201, override:203, readonly:209, accessor:211, new:401};\nconst spec_LessThan = {__proto__:null,\"<\":193};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]\",\n  stateData: \"((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~\",\n  goto: \"$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V\",\n  nodeNames: \"⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 379,\n  context: trackNewline,\n  nodeProps: [\n    [\"isolate\", -8,5,6,14,37,39,51,53,55,\"\"],\n    [\"group\", -26,9,17,19,68,207,211,215,216,218,221,224,234,236,242,244,246,248,251,257,263,265,267,269,271,273,274,\"Statement\",-34,13,14,32,35,36,42,51,54,55,57,62,70,72,76,80,82,84,85,110,111,120,121,136,139,141,142,143,144,145,147,148,167,169,171,\"Expression\",-23,31,33,37,41,43,45,173,175,177,178,180,181,182,184,185,186,188,189,190,201,203,205,206,\"Type\",-3,88,103,109,\"ClassItem\"],\n    [\"openedBy\", 23,\"<\",38,\"InterpolationStart\",56,\"[\",60,\"{\",73,\"(\",160,\"JSXStartCloseTag\"],\n    [\"closedBy\", -2,24,168,\">\",40,\"InterpolationEnd\",50,\"]\",61,\"}\",74,\")\",165,\"JSXEndTag\"]\n  ],\n  propSources: [jsHighlight],\n  skippedNodes: [0,5,6,277],\n  repeatNodeCount: 37,\n  tokenData: \"$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~\", 141, 339), new LocalTokenGroup(\"j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~\", 25, 322)],\n  topRules: {\"Script\":[0,7],\"SingleExpression\":[1,275],\"SingleClassItem\":[2,276]},\n  dialects: {jsx: 0, ts: 15098},\n  dynamicPrecedences: {\"80\":1,\"82\":1,\"94\":1,\"169\":1,\"199\":1},\n  specialized: [{term: 326, get: (value) => spec_identifier[value] || -1},{term: 342, get: (value) => spec_word[value] || -1},{term: 95, get: (value) => spec_LessThan[value] || -1}],\n  tokenPrec: 15124\n});\n\nexport { parser };\n", "import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \"JSXText\", \"JSXAttributeValue\", \"JSXOpenTag\", \"JSXCloseTag\", \"JSXSelfClosingTag\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^\\s*{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            var _a;\n            if ((_a = desc.meta.docs) === null || _a === void 0 ? void 0 : _a.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };\n", "import { parser, configureNesting } from '@lezer/html';\nimport { cssLanguage, css } from '@codemirror/lang-css';\nimport { javascriptLanguage, typescriptLanguage, jsxLanguage, tsxLanguage, javascript } from '@codemirror/lang-javascript';\nimport { EditorView } from '@codemirror/view';\nimport { EditorSelection } from '@codemirror/state';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\n\nconst Targets = [\"_blank\", \"_self\", \"_top\", \"_parent\"];\nconst Charsets = [\"ascii\", \"utf-8\", \"utf-16\", \"latin1\", \"latin1\"];\nconst Methods = [\"get\", \"post\", \"put\", \"delete\"];\nconst Encs = [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"];\nconst Bool = [\"true\", \"false\"];\nconst S = {}; // Empty tag spec\nconst Tags = {\n    a: {\n        attrs: {\n            href: null, ping: null, type: null,\n            media: null,\n            target: Targets,\n            hreflang: null\n        }\n    },\n    abbr: S,\n    address: S,\n    area: {\n        attrs: {\n            alt: null, coords: null, href: null, target: null, ping: null,\n            media: null, hreflang: null, type: null,\n            shape: [\"default\", \"rect\", \"circle\", \"poly\"]\n        }\n    },\n    article: S,\n    aside: S,\n    audio: {\n        attrs: {\n            src: null, mediagroup: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"],\n            preload: [\"none\", \"metadata\", \"auto\"],\n            autoplay: [\"autoplay\"],\n            loop: [\"loop\"],\n            controls: [\"controls\"]\n        }\n    },\n    b: S,\n    base: { attrs: { href: null, target: Targets } },\n    bdi: S,\n    bdo: S,\n    blockquote: { attrs: { cite: null } },\n    body: S,\n    br: S,\n    button: {\n        attrs: {\n            form: null, formaction: null, name: null, value: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"autofocus\"],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\"novalidate\"],\n            formtarget: Targets,\n            type: [\"submit\", \"reset\", \"button\"]\n        }\n    },\n    canvas: { attrs: { width: null, height: null } },\n    caption: S,\n    center: S,\n    cite: S,\n    code: S,\n    col: { attrs: { span: null } },\n    colgroup: { attrs: { span: null } },\n    command: {\n        attrs: {\n            type: [\"command\", \"checkbox\", \"radio\"],\n            label: null, icon: null, radiogroup: null, command: null, title: null,\n            disabled: [\"disabled\"],\n            checked: [\"checked\"]\n        }\n    },\n    data: { attrs: { value: null } },\n    datagrid: { attrs: { disabled: [\"disabled\"], multiple: [\"multiple\"] } },\n    datalist: { attrs: { data: null } },\n    dd: S,\n    del: { attrs: { cite: null, datetime: null } },\n    details: { attrs: { open: [\"open\"] } },\n    dfn: S,\n    div: S,\n    dl: S,\n    dt: S,\n    em: S,\n    embed: { attrs: { src: null, type: null, width: null, height: null } },\n    eventsource: { attrs: { src: null } },\n    fieldset: { attrs: { disabled: [\"disabled\"], form: null, name: null } },\n    figcaption: S,\n    figure: S,\n    footer: S,\n    form: {\n        attrs: {\n            action: null, name: null,\n            \"accept-charset\": Charsets,\n            autocomplete: [\"on\", \"off\"],\n            enctype: Encs,\n            method: Methods,\n            novalidate: [\"novalidate\"],\n            target: Targets\n        }\n    },\n    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,\n    head: {\n        children: [\"title\", \"base\", \"link\", \"style\", \"meta\", \"script\", \"noscript\", \"command\"]\n    },\n    header: S,\n    hgroup: S,\n    hr: S,\n    html: {\n        attrs: { manifest: null }\n    },\n    i: S,\n    iframe: {\n        attrs: {\n            src: null, srcdoc: null, name: null, width: null, height: null,\n            sandbox: [\"allow-top-navigation\", \"allow-same-origin\", \"allow-forms\", \"allow-scripts\"],\n            seamless: [\"seamless\"]\n        }\n    },\n    img: {\n        attrs: {\n            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"]\n        }\n    },\n    input: {\n        attrs: {\n            alt: null, dirname: null, form: null, formaction: null,\n            height: null, list: null, max: null, maxlength: null, min: null,\n            name: null, pattern: null, placeholder: null, size: null, src: null,\n            step: null, value: null, width: null,\n            accept: [\"audio/*\", \"video/*\", \"image/*\"],\n            autocomplete: [\"on\", \"off\"],\n            autofocus: [\"autofocus\"],\n            checked: [\"checked\"],\n            disabled: [\"disabled\"],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\"novalidate\"],\n            formtarget: Targets,\n            multiple: [\"multiple\"],\n            readonly: [\"readonly\"],\n            required: [\"required\"],\n            type: [\"hidden\", \"text\", \"search\", \"tel\", \"url\", \"email\", \"password\", \"datetime\", \"date\", \"month\",\n                \"week\", \"time\", \"datetime-local\", \"number\", \"range\", \"color\", \"checkbox\", \"radio\",\n                \"file\", \"submit\", \"image\", \"reset\", \"button\"]\n        }\n    },\n    ins: { attrs: { cite: null, datetime: null } },\n    kbd: S,\n    keygen: {\n        attrs: {\n            challenge: null, form: null, name: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            keytype: [\"RSA\"]\n        }\n    },\n    label: { attrs: { for: null, form: null } },\n    legend: S,\n    li: { attrs: { value: null } },\n    link: {\n        attrs: {\n            href: null, type: null,\n            hreflang: null,\n            media: null,\n            sizes: [\"all\", \"16x16\", \"16x16 32x32\", \"16x16 32x32 64x64\"]\n        }\n    },\n    map: { attrs: { name: null } },\n    mark: S,\n    menu: { attrs: { label: null, type: [\"list\", \"context\", \"toolbar\"] } },\n    meta: {\n        attrs: {\n            content: null,\n            charset: Charsets,\n            name: [\"viewport\", \"application-name\", \"author\", \"description\", \"generator\", \"keywords\"],\n            \"http-equiv\": [\"content-language\", \"content-type\", \"default-style\", \"refresh\"]\n        }\n    },\n    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },\n    nav: S,\n    noscript: S,\n    object: {\n        attrs: {\n            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,\n            typemustmatch: [\"typemustmatch\"]\n        }\n    },\n    ol: { attrs: { reversed: [\"reversed\"], start: null, type: [\"1\", \"a\", \"A\", \"i\", \"I\"] },\n        children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"] },\n    optgroup: { attrs: { disabled: [\"disabled\"], label: null } },\n    option: { attrs: { disabled: [\"disabled\"], label: null, selected: [\"selected\"], value: null } },\n    output: { attrs: { for: null, form: null, name: null } },\n    p: S,\n    param: { attrs: { name: null, value: null } },\n    pre: S,\n    progress: { attrs: { value: null, max: null } },\n    q: { attrs: { cite: null } },\n    rp: S,\n    rt: S,\n    ruby: S,\n    samp: S,\n    script: {\n        attrs: {\n            type: [\"text/javascript\"],\n            src: null,\n            async: [\"async\"],\n            defer: [\"defer\"],\n            charset: Charsets\n        }\n    },\n    section: S,\n    select: {\n        attrs: {\n            form: null, name: null, size: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            multiple: [\"multiple\"]\n        }\n    },\n    slot: { attrs: { name: null } },\n    small: S,\n    source: { attrs: { src: null, type: null, media: null } },\n    span: S,\n    strong: S,\n    style: {\n        attrs: {\n            type: [\"text/css\"],\n            media: null,\n            scoped: null\n        }\n    },\n    sub: S,\n    summary: S,\n    sup: S,\n    table: S,\n    tbody: S,\n    td: { attrs: { colspan: null, rowspan: null, headers: null } },\n    template: S,\n    textarea: {\n        attrs: {\n            dirname: null, form: null, maxlength: null, name: null, placeholder: null,\n            rows: null, cols: null,\n            autofocus: [\"autofocus\"],\n            disabled: [\"disabled\"],\n            readonly: [\"readonly\"],\n            required: [\"required\"],\n            wrap: [\"soft\", \"hard\"]\n        }\n    },\n    tfoot: S,\n    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: [\"row\", \"col\", \"rowgroup\", \"colgroup\"] } },\n    thead: S,\n    time: { attrs: { datetime: null } },\n    title: S,\n    tr: S,\n    track: {\n        attrs: {\n            src: null, label: null, default: null,\n            kind: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"],\n            srclang: null\n        }\n    },\n    ul: { children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"] },\n    var: S,\n    video: {\n        attrs: {\n            src: null, poster: null, width: null, height: null,\n            crossorigin: [\"anonymous\", \"use-credentials\"],\n            preload: [\"auto\", \"metadata\", \"none\"],\n            autoplay: [\"autoplay\"],\n            mediagroup: [\"movie\"],\n            muted: [\"muted\"],\n            controls: [\"controls\"]\n        }\n    },\n    wbr: S\n};\nconst GlobalAttrs = {\n    accesskey: null,\n    class: null,\n    contenteditable: Bool,\n    contextmenu: null,\n    dir: [\"ltr\", \"rtl\", \"auto\"],\n    draggable: [\"true\", \"false\", \"auto\"],\n    dropzone: [\"copy\", \"move\", \"link\", \"string:\", \"file:\"],\n    hidden: [\"hidden\"],\n    id: null,\n    inert: [\"inert\"],\n    itemid: null,\n    itemprop: null,\n    itemref: null,\n    itemscope: [\"itemscope\"],\n    itemtype: null,\n    lang: [\"ar\", \"bn\", \"de\", \"en-GB\", \"en-US\", \"es\", \"fr\", \"hi\", \"id\", \"ja\", \"pa\", \"pt\", \"ru\", \"tr\", \"zh\"],\n    spellcheck: Bool,\n    autocorrect: Bool,\n    autocapitalize: Bool,\n    style: null,\n    tabindex: null,\n    title: null,\n    translate: [\"yes\", \"no\"],\n    rel: [\"stylesheet\", \"alternate\", \"author\", \"bookmark\", \"help\", \"license\", \"next\", \"nofollow\", \"noreferrer\", \"prefetch\", \"prev\", \"search\", \"tag\"],\n    role: /*@__PURE__*/\"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer\".split(\" \"),\n    \"aria-activedescendant\": null,\n    \"aria-atomic\": Bool,\n    \"aria-autocomplete\": [\"inline\", \"list\", \"both\", \"none\"],\n    \"aria-busy\": Bool,\n    \"aria-checked\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n    \"aria-controls\": null,\n    \"aria-describedby\": null,\n    \"aria-disabled\": Bool,\n    \"aria-dropeffect\": null,\n    \"aria-expanded\": [\"true\", \"false\", \"undefined\"],\n    \"aria-flowto\": null,\n    \"aria-grabbed\": [\"true\", \"false\", \"undefined\"],\n    \"aria-haspopup\": Bool,\n    \"aria-hidden\": Bool,\n    \"aria-invalid\": [\"true\", \"false\", \"grammar\", \"spelling\"],\n    \"aria-label\": null,\n    \"aria-labelledby\": null,\n    \"aria-level\": null,\n    \"aria-live\": [\"off\", \"polite\", \"assertive\"],\n    \"aria-multiline\": Bool,\n    \"aria-multiselectable\": Bool,\n    \"aria-owns\": null,\n    \"aria-posinset\": null,\n    \"aria-pressed\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n    \"aria-readonly\": Bool,\n    \"aria-relevant\": null,\n    \"aria-required\": Bool,\n    \"aria-selected\": [\"true\", \"false\", \"undefined\"],\n    \"aria-setsize\": null,\n    \"aria-sort\": [\"ascending\", \"descending\", \"none\", \"other\"],\n    \"aria-valuemax\": null,\n    \"aria-valuemin\": null,\n    \"aria-valuenow\": null,\n    \"aria-valuetext\": null\n};\nconst eventAttributes = /*@__PURE__*/(\"beforeunload copy cut dragstart dragover dragleave dragenter dragend \" +\n    \"drag paste focus blur change click load mousedown mouseenter mouseleave \" +\n    \"mouseup keydown keyup resize scroll unload\").split(\" \").map(n => \"on\" + n);\nfor (let a of eventAttributes)\n    GlobalAttrs[a] = null;\nclass Schema {\n    constructor(extraTags, extraAttrs) {\n        this.tags = Object.assign(Object.assign({}, Tags), extraTags);\n        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);\n        this.allTags = Object.keys(this.tags);\n        this.globalAttrNames = Object.keys(this.globalAttrs);\n    }\n}\nSchema.default = /*@__PURE__*/new Schema;\nfunction elementName(doc, tree, max = doc.length) {\n    if (!tree)\n        return \"\";\n    let tag = tree.firstChild;\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : \"\";\n}\nfunction findParentElement(tree, skip = false) {\n    for (; tree; tree = tree.parent)\n        if (tree.name == \"Element\") {\n            if (skip)\n                skip = false;\n            else\n                return tree;\n        }\n    return null;\n}\nfunction allowedChildren(doc, tree, schema) {\n    let parentInfo = schema.tags[elementName(doc, findParentElement(tree))];\n    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;\n}\nfunction openTags(doc, tree) {\n    let open = [];\n    for (let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {\n        let tagName = elementName(doc, parent);\n        if (tagName && parent.lastChild.name == \"CloseTag\")\n            break;\n        if (tagName && open.indexOf(tagName) < 0 && (tree.name == \"EndTag\" || tree.from >= parent.firstChild.to))\n            open.push(tagName);\n    }\n    return open;\n}\nconst identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction completeTag(state, schema, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    let parent = findParentElement(tree, true);\n    return { from, to,\n        options: allowedChildren(state.doc, parent, schema).map(tagName => ({ label: tagName, type: \"type\" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: \"/\" + tag, apply: \"/\" + tag + end,\n            type: \"type\", boost: 99 - i }))),\n        validFor: /^\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/ };\n}\nfunction completeCloseTag(state, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    return { from, to,\n        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: \"type\", boost: 99 - i })),\n        validFor: identifier };\n}\nfunction completeStartTag(state, schema, tree, pos) {\n    let options = [], level = 0;\n    for (let tagName of allowedChildren(state.doc, tree, schema))\n        options.push({ label: \"<\" + tagName, type: \"type\" });\n    for (let open of openTags(state.doc, tree))\n        options.push({ label: \"</\" + open + \">\", type: \"type\", boost: 99 - level++ });\n    return { from: pos, to: pos, options, validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/ };\n}\nfunction completeAttrName(state, schema, tree, from, to) {\n    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];\n    let names = info && info.globalAttrs === false ? localAttrs\n        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;\n    return { from, to,\n        options: names.map(attrName => ({ label: attrName, type: \"property\" })),\n        validFor: identifier };\n}\nfunction completeAttrValue(state, schema, tree, from, to) {\n    var _a;\n    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild(\"AttributeName\");\n    let options = [], token = undefined;\n    if (nameNode) {\n        let attrName = state.sliceDoc(nameNode.from, nameNode.to);\n        let attrs = schema.globalAttrs[attrName];\n        if (!attrs) {\n            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];\n        }\n        if (attrs) {\n            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '\"', quoteEnd = '\"';\n            if (/^['\"]/.test(base)) {\n                token = base[0] == '\"' ? /^[^\"]*$/ : /^[^']*$/;\n                quoteStart = \"\";\n                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? \"\" : base[0];\n                base = base.slice(1);\n                from++;\n            }\n            else {\n                token = /^[^\\s<>='\"]*$/;\n            }\n            for (let value of attrs)\n                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: \"constant\" });\n        }\n    }\n    return { from, to, options, validFor: token };\n}\nfunction htmlCompletionFor(schema, context) {\n    let { state, pos } = context, tree = syntaxTree(state).resolveInner(pos, -1), around = tree.resolve(pos);\n    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {\n        let last = before.lastChild;\n        if (!last || !last.type.isError || last.from < last.to)\n            break;\n        around = tree = before;\n        scan = last.from;\n    }\n    if (tree.name == \"TagName\") {\n        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)\n            : completeTag(state, schema, tree, tree.from, pos);\n    }\n    else if (tree.name == \"StartTag\") {\n        return completeTag(state, schema, tree, pos, pos);\n    }\n    else if (tree.name == \"StartCloseTag\" || tree.name == \"IncompleteCloseTag\") {\n        return completeCloseTag(state, tree, pos, pos);\n    }\n    else if (tree.name == \"OpenTag\" || tree.name == \"SelfClosingTag\" || tree.name == \"AttributeName\") {\n        return completeAttrName(state, schema, tree, tree.name == \"AttributeName\" ? tree.from : pos, pos);\n    }\n    else if (tree.name == \"Is\" || tree.name == \"AttributeValue\" || tree.name == \"UnquotedAttributeValue\") {\n        return completeAttrValue(state, schema, tree, tree.name == \"Is\" ? pos : tree.from, pos);\n    }\n    else if (context.explicit && (around.name == \"Element\" || around.name == \"Text\" || around.name == \"Document\")) {\n        return completeStartTag(state, schema, tree, pos);\n    }\n    else {\n        return null;\n    }\n}\n/**\nHTML tag completion. Opens and closes tags and attributes in a\ncontext-aware way.\n*/\nfunction htmlCompletionSource(context) {\n    return htmlCompletionFor(Schema.default, context);\n}\n/**\nCreate a completion source for HTML extended with additional tags\nor attributes.\n*/\nfunction htmlCompletionSourceWith(config) {\n    let { extraTags, extraGlobalAttributes: extraAttrs } = config;\n    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;\n    return (context) => htmlCompletionFor(schema, context);\n}\n\nconst jsonParser = /*@__PURE__*/javascriptLanguage.parser.configure({ top: \"SingleExpression\" });\nconst defaultNesting = [\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/typescript\" || attrs.lang == \"ts\",\n        parser: typescriptLanguage.parser },\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/babel\" || attrs.type == \"text/jsx\",\n        parser: jsxLanguage.parser },\n    { tag: \"script\",\n        attrs: attrs => attrs.type == \"text/typescript-jsx\",\n        parser: tsxLanguage.parser },\n    { tag: \"script\",\n        attrs(attrs) {\n            return /^(importmap|speculationrules|application\\/(.+\\+)?json)$/i.test(attrs.type);\n        },\n        parser: jsonParser },\n    { tag: \"script\",\n        attrs(attrs) {\n            return !attrs.type || /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);\n        },\n        parser: javascriptLanguage.parser },\n    { tag: \"style\",\n        attrs(attrs) {\n            return (!attrs.lang || attrs.lang == \"css\") && (!attrs.type || /^(text\\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));\n        },\n        parser: cssLanguage.parser }\n];\nconst defaultAttrs = /*@__PURE__*/[\n    { name: \"style\",\n        parser: /*@__PURE__*/cssLanguage.parser.configure({ top: \"Styles\" }) }\n].concat(/*@__PURE__*/eventAttributes.map(name => ({ name, parser: javascriptLanguage.parser })));\n/**\nA language provider based on the [Lezer HTML\nparser](https://github.com/lezer-parser/html), extended with the\nJavaScript and CSS parsers to parse the content of `<script>` and\n`<style>` tags.\n*/\nconst htmlPlain = /*@__PURE__*/LRLanguage.define({\n    name: \"html\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let after = /^(\\s*)(<\\/)?/.exec(context.textAfter);\n                    if (context.node.to <= context.pos + after[0].length)\n                        return context.continue();\n                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                },\n                Document(context) {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length < context.node.to)\n                        return context.continue();\n                    let endElt = null, close;\n                    for (let cur = context.node;;) {\n                        let last = cur.lastChild;\n                        if (!last || last.name != \"Element\" || last.to != cur.to)\n                            break;\n                        endElt = cur = last;\n                    }\n                    if (endElt && !((close = endElt.lastChild) && (close.name == \"CloseTag\" || close.name == \"SelfClosingTag\")))\n                        return context.lineIndent(endElt.from) + context.unit;\n                    return null;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(node) {\n                    let first = node.firstChild, last = node.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : node.to };\n                }\n            }),\n            /*@__PURE__*/bracketMatchingHandle.add({\n                \"OpenTag CloseTag\": node => node.getChild(\"TagName\")\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/\\w+\\W$/,\n        wordChars: \"-._\"\n    }\n});\n/**\nA language provider based on the [Lezer HTML\nparser](https://github.com/lezer-parser/html), extended with the\nJavaScript and CSS parsers to parse the content of `<script>` and\n`<style>` tags.\n*/\nconst htmlLanguage = /*@__PURE__*/htmlPlain.configure({\n    wrap: /*@__PURE__*/configureNesting(defaultNesting, defaultAttrs)\n});\n/**\nLanguage support for HTML, including\n[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and\nCSS support extensions.\n*/\nfunction html(config = {}) {\n    let dialect = \"\", wrap;\n    if (config.matchClosingTags === false)\n        dialect = \"noMatch\";\n    if (config.selfClosingTags === true)\n        dialect = (dialect ? dialect + \" \" : \"\") + \"selfClosing\";\n    if (config.nestedLanguages && config.nestedLanguages.length ||\n        config.nestedAttributes && config.nestedAttributes.length)\n        wrap = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));\n    let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;\n    return new LanguageSupport(lang, [\n        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),\n        config.autoCloseTags !== false ? autoCloseTags : [],\n        javascript().support,\n        css().support\n    ]);\n}\nconst selfClosers = /*@__PURE__*/new Set(/*@__PURE__*/\"area base br col command embed frame hr img input keygen link meta param source track wbr menuitem\".split(\" \"));\n/**\nExtension that will automatically insert close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, insertTransaction) => {\n    if (view.composing || view.state.readOnly || from != to || (text != \">\" && text != \"/\") ||\n        !htmlLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = insertTransaction(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a, _b, _c;\n        let didType = state.doc.sliceString(range.from - 1, range.to) == text;\n        let { head } = range, after = syntaxTree(state).resolveInner(head, -1), name;\n        if (didType && text == \">\" && after.name == \"EndTag\") {\n            let tag = after.parent;\n            if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != \"CloseTag\" &&\n                (name = elementName(state.doc, tag.parent, head)) &&\n                !selfClosers.has(name)) {\n                let to = head + (state.doc.sliceString(head, head + 1) === \">\" ? 1 : 0);\n                let insert = `</${name}>`;\n                return { range, changes: { from: head, to, insert } };\n            }\n        }\n        else if (didType && text == \"/\" && after.name == \"IncompleteCloseTag\") {\n            let tag = after.parent;\n            if (after.from == head - 2 && ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != \"CloseTag\" &&\n                (name = elementName(state.doc, tag, head)) && !selfClosers.has(name)) {\n                let to = head + (state.doc.sliceString(head, head + 1) === \">\" ? 1 : 0);\n                let insert = `${name}>`;\n                return {\n                    range: EditorSelection.cursor(head + insert.length, -1),\n                    changes: { from: head, to, insert }\n                };\n            }\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, {\n            userEvent: \"input.complete\",\n            scrollIntoView: true\n        })\n    ]);\n    return true;\n});\n\nexport { autoCloseTags, html, htmlCompletionSource, htmlCompletionSourceWith, htmlLanguage, htmlPlain };\n", "import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [], context = [];\n    for (let cur = node; cur; cur = cur.parent) {\n        if (cur.name == \"FencedCode\")\n            return context;\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, -1) && !markdownLanguage.isActiveAt(state, range.from, 1))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e\n            ? countColumn(line.text, 4, context[i + 1].from) - insert.length\n            : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlTagLanguage.support, headerIndent], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],
  "mappings": "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",
  "names": ["hash", "Type", "elt", "count", "parser", "nodeTypes", "id", "spec", "node", "m", "next", "parser", "count", "i", "Type", "data", "id", "FragmentCursor", "values", "Element", "parser", "tags", "id", "attrs", "space", "dash", "id", "callee", "parser", "tags", "identifier", "callee", "node", "parser", "newline", "space", "slash", "question", "bracketL", "spec_identifier", "parser", "id", "node", "parser", "base", "elementName", "identifier", "elt", "parser", "autoCloseTags", "selfClosers", "to", "parser", "node", "space", "insert", "changes"]
}
